Allison Delgado
CS163 - Spring Term 2021
April 30, 2021
Prof. Karla Fant

Programming Assignment 2: Stack and Queue ADT

	For this project, I used a stack and a queue to hold questions for a trivia game. There was two implementations of the stack: one for used questions and one for correctly answered questions. The queue held unused questions. I believe that for this task, a stack and queue were the best data structures to use since they each provided easy access to the nodes needed. Because the queue was implemented in a circular linked list, insertion and removal was simple and did not require traversal. We were simply able to insert at the rear pointer's next node, and remove there as well. This increased the overall efficiency of the program since traversal can be very time consuming if there are a lot of elements to traverse. If the queue were implemented in a linear linked list, we would have had to traverse to add a new node, which would not have been as efficient as a circular linked list. However for a stack, I believe a linear linked list was the best option since insertion is always at the head, and so is removal. This meant that there was also no traversal for either of these operations, which benefitted efficiency.
	I do not believe that another data structure would have worked better for either of these cases. For instance, another common way to implement a stack and queue is by using arrays. The difficulty with arrays is that when you delete an element, everything must shift over so as to fill the hole that was left. By avoiding a shift operation, we made our program more efficient since linked lists, whether circular or linear, do not require any shifting. Although arrays have the benefit of direct access to any index, I would elect not to use them due to their tedious and inefficient nature of shifting.
	Because I implemented a stack and queue using linked lists, no traversal was required to add or remove, simply due to the nature of a stack and a queue. With a stack, you are inserting at the top of the list, and removing the topmost element as well. There is no required traversal. With a queue, you insert at the end of the list, and remove from the last element. Again, there is no required traversal. These data structures almost share some benefits of an array in the sense that there is direct access for adding and removing. A linked list may be the best of both worlds due to this and the fact that it has a flexible size and does not require shifting. 
	One major efficiency issue has to do with memory efficiency. Linked lists require more memory since each node also stores a reference to the next node. This meant that, with three instances of a list, this program required a lot of memory. Something like an array would have been more memory efficient. And although adding and removing in this case were almost "direct access", traversal could not have been avoided completely. Things like displaying or deallocating the whole list still required traversal. This is something that could not be avoided though since there would be no other way to walk through the entire list.
	If I had more time to solve the problem, I might experiment with implementing arrays instead of linked lists. I still do think that for this application, a linked list is the most efficient data structure however I wonder if the direct access of an array would be beneficial for run time performance. But it could be interesting to see if the pro of direct access outweighed the con of shifting. However, one issue with arrays is that they are of a set size, so if I was to use an array I'd have to ensure that it would never get completely full. This would require me to increase the size of the array by creating a new one with a greater size and copying over the contents. Walking through an array using a loop is different than traversing a linear linked list in terms of efficiency, so I wonder if the program's efficiency would increase or decrease overall as a result of using arrays.